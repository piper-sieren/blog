[{"categories":["Windows","IIS"],"content":"Create an SSL Certificate for IIS 10 Generate the .csr from IIS GUI Navigate to your site’s home and select on ‘Server Certificates’ located under ISS In the far right Actions pane, select ‘Create Certificate Request’ Fill out the Distinguished Name Properties form. This includes the following fields: Common name, Organization, Organizational unit, City/locality, State/province, and Country/region. Select Next Leave the Cryptographic service provider and Bit length as default, then select Next Save the .csr file to your local machine Export the file in format .pfx using mcc Go to Start -\u003e Run and type ‘mmc’ to open the Microsoft Management Console From the MMC menu bar and select File -\u003e Add/Remove Snap-in Select the Add button and select Certificates from the list. Select Add Slect the Computer Account. Click Next, Close, and Ok. Navigate to Certificate Enrollment Requests -\u003e Certificates Right click your previously created certificate and select All Tasks -\u003e Export… Choose Export with private key on the radio button options, select Next. In the certificate export wizard select Personal Information Exchange - PKCS #12 (.PFX) Set a password, Browse to where you would like to save your export, and click Next, then Finished Convert .pfx to RSA private key format Navigate to the downloaded location of the .pfx file using CMD Type the following command to first convert the .pfx file to .pem 1 openssl pkcs12 -in filename.pfx -nocerts -out key.pem Type the following command to convert the .pem file to .key 1 openssl rsa -in key.pem -out myserver.key Upload your Certificate Signing Request and Private Key to your preverd Certificate Authority (CA) Download Response from CA Download the .crt file generated as a response from the Certificate Authority (CA) Navigate to the file path inside your CMD and use the following to convert the files to a .pfx format 1 openssl pkcs12 -export-certpbe PBE-SHA1-3DES -keypbe PBE-SHA1-3DES -nomac -inkey myserver.key -in downloaded.crt -out example.com.pfx Upload to IIS Navigate to your site’s home and select on ‘Server Certificates’ located under ISS In the far right Actions pane, select ‘Complete Certificate Signing Request’ Upload your created .pks file Site Bindings Navigate to your desired IIS Site and select Bindings in the far right Actions pane Select Add Fill out Add site bindings with the following: https, All Unassigned, port 443, and choose your certificate from the dropdown menu. Select OK ","description":"Create an SSL Certificate for IIS 10","tags":["Windows","SSL","OpenSSL"],"title":"Create an SSL Certificate for IIS 10","uri":"/posts/iisssl/"},{"categories":null,"content":"Azure offers Blob Storage as the cloud storage solution. Blob Storage is a way of storing substantial amounts of unstructured data: data that doesn’t adhere to a specific data model or definition- data that can’t go into rows and columns. For example, video, audio, image, log files, text files, etc. Azure Blob Storage has three types of resources to offer:\nThe Storage Account Container(s) within the storage account Blob(s) within the Container Prerequisites Azure Subscription Azure Storage Account The current .Net Core SDK for your OS First, you will need to set up a .NET Core project. Do this with whichever method you please. I typically use Visual Studios, but some prefer doing this directly in their Terminal of choice.\nNext, you will need to connect your Storage Account to your .NET Core project. Do this by generating an Access Key inside your Azure Storage Account. Copy the “Connection String” value generated for key1.\nThen, set this value as an environment variable named “AZURE_STORAGE_CONNECTION_STRING”. An easy way to set an environment variable without navigating through your system settings is to use your OS Command Prompt. For windows, that would be the CMD with the following syntax:\n1 set AZURE_STORAGE_CONNECTION_STRING \u003cyourconnectionstring\u003e .Net classes to interact with Azure Storage Resources\nBlobServiceClient: manipulate Azure Storage resources and blob containers\nBlobContainerClient: manipulate Azure Storage containers and their blobs\nBlobClient: manipulate Azure Storage Blobs\nBlobDownloadInfo: Represent the properties and content returned from downloading a Blob\nTip: Retrieve the Azure Storage Account’s Connection String inside your .NET\nproject- From your previously set environment variables.\n1 string connectionString = Environment.GetEnvironmentVariable(\"AZURE_STORAGE_CONNECTION_STRING\"); Tip: Add the Azure Blob Storage .Net Client Library with the using statement. 1 2 3 4 5 using Azure.Storage; using Azure.Storage.Blobs; using Azure.Storage.Blobs.Models; Code Examples: Retrieve the Azure Store Account’s Connection String – Environment Variable: 1 string connectionString = Environment.GetEnvironmentVariable(\"AZURE_STORAGE_CONNECTION_STRING\"); List Blobs in a Container: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 BlobContainerClient blobContainerClient = new BlobContainerClient(connectionString, \"burpgrid\"); Console.WriteLine(\"Listing blobs...\"); var blobnames = new List\u003cstring\u003e(); // List all blobs in the container await foreach (BlobItem blobItem in blobContainerClient.GetBlobsAsync()) { Console.WriteLine(\"\\t\" + blobItem.Name); blobnames.Add(blobItem.Name); } Download Contents from each Blob in a Container to Local: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 foreach (string blobname in blobnames) { string localFilePath = Path.Combine(localPath, blobname); // Connect to each blob client BlobClient blobClient = blobContainerClient.GetBlobClient(blobname); // Download the blob's contents and save it to a file BlobDownloadInfo download = await blobClient.DownloadAsync(); using (FileStream downloadFileStream = File.OpenWrite(localFilePath)) { await download.Content.CopyToAsync(downloadFileStream); downloadFileStream.Close(); } } Clear Local File Path: 1 2 3 4 5 6 7 8 9 //Delete all files in local file path string localPath = “/.data/” string[] filePaths = Directory.GetFiles(localPath); foreach (string filePath in filePaths) File.Delete(filePath); Open and Read File Contents to Class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //Open and read files foreach (string blobname in blobnames) { string localFilePath = Path.Combine(localPath, blobname); string text = System.IO.File.ReadAllText(localFilePath); //Convert to saved JSON var scan = JsonConvert.DeserializeObject\u003cScanResults\u003e(text); Console.WriteLine(\"issue counts: \" + scan.issue_counts.total); Console.WriteLine(\"site name: \" + scan.site_name); } Additional resources: API reference documentation\nLibrary source code\nPackage (NuGet)\nSamples\nMicrosoft Documentation\n","description":"Azure Blob Storage + .NET Client Library","tags":[".Net","Azure","Blob Storage"],"title":"Azure Blob Storage + .NET Client Library","uri":"/posts/azureblobstorage/"},{"categories":["Azure","PowerShell"],"content":"Prerequisites Assigning TLS1.2 to Storage Account and VM\nAdding the VM to the firewall subnet inclusions\nCreate a System Managed Identity and assign to VM\nGive that System Managed Identity RBAC over the storage account\nAzure PowerShell Modules 1 2 3 4 5 6 7 Install-Module AzureRM Install-Module Azure -AllowClobber Install-Module Az -AllowClobber #AllowClobber flag removes the overlap between AzureRM, Az, and Azure PS Modules’ conflicting command names. PowerShell Script TLS1.2 can be set it the portal settings as well – following command must have Admin privs. 1 [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 The purpose of these self-assigned link-local addresses is to facilitate communication with other hosts within the subnet even in the absence of external address configuration (via manual input or DHCP). Unlike in IPv6, implementation of IPv4 link-local addresses is recommended only in the absence of a normal, routable address. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $response = Invoke-WebRequest -Uri 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\u0026resource=https%3A%2F%2Fmanagement.azure.com%2F' -Method GET -Headers @{Metadata=\"true\"} $content = $response.Content | ConvertFrom-Json $ArmToken = $content.access_token $params = @{canonicalizedResource=\"/\u003ccontainer name\u003e/\u003cstorage account\u003e/\u003cblob name\u003e\";signedResource=\"c\";signedPermission=\"rcw\";signedProtocol=\"https\";signedExpiry=\"\u003csigned expiry\u003e\"} $jsonParams = $params | ConvertTo-Json $sasResponse = Invoke-WebRequest -Uri https://management.azure.com/subscriptions/\u003csubscription\u003e/resourceGroups/\u003cresource group\u003e /providers/Microsoft.Storage/storageAccounts/\u003cstorage account\u003e/listServiceSas/?api-version=2017-06-01 -Method POST -Body $jsonParams -Headers @{Authorization=\"Bearer $ArmToken\"} $sasContent = $sasResponse.Content | ConvertFrom-Json $sasCred = $sasContent.serviceSasToken $ctx = New-AzStorageContext -StorageAccountName a3dvcseburpstr01 -SasToken $sasCred The following function uploads a blank test file to the blob container 1 Set-AzStorageBlobContent -File test.txt -Container \u003ccontainer name\u003e -Blob \u003cblob name\u003e-Context $ctx Terminology SAS Credential: A Service SAS provides the ability to grant limited access to objects in a storage account, for limited time and a specific service (in our case, the blob service), without exposing an account access key.\nPowerShell Module: A module is a package that contains PowerShell members, such as cmdlets, providers, functions, workflows, variables, and aliases. The members of this package can be implemented in a PowerShell script, a compiled DLL, or a combination of both. These files are usually grouped together in a single directory.\nManaged Identities: On Azure, managed identities eliminate the need for developers having to manage credentials by providing an identity for the Azure resource in Azure AD and using it to obtain Azure Active Directory (Azure AD) tokens. This also helps accessing Azure Key Vault where developers can store credentials in a secure manner. Managed identities for Azure resources solve this problem by providing Azure services with an automatically managed identity in Azure AD.\nTLS1.2: Why use TLS 1.2 with Configuration Manager? TLS 1.2 is more secure than the previous cryptographic protocols such as SSL 2.0, SSL 3.0, TLS 1.0, and TLS 1.1. Essentially, TLS 1.2 keeps data being transferred across the network more secure.\nReference Documents \u0026 Videos Getting started with PowerShell for Azure\nTutorial: Use a Windows VM system-assigned managed identity to access Azure Storage via a SAS credential\n","description":"Use a Windows VM system-assigned managed identity to access Azure Storage via a SAS credential","tags":["PowerShell","Azure"],"title":"Use a Windows VM system-assigned managed identity to access Azure Storage via a SAS credential","uri":"/posts/azurepowershell/"}]
